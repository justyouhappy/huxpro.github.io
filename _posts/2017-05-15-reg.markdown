---
layout:     post
title:      "正则表达式总结笔记"
subtitle:   "正则表达式使用"
date:       2017-05-15
author:     "Alan"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
    - 前端
    - javascript
---

> live like youself. 

# 简单分类

---

## 简单类
原则上正则的一个字符对应一个字符如：如/ruby/，匹配ruby字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符如/[ruby]/ ,只匹配其中一个字符

## 负向类
前面加个元字符进行取反，表示匹配不能为括号里面的字符

## 范围类
如/[a-f]/,/[1-2]/

## 组合类
允许用中括号匹配不同类型的单个字符。

## 预定义类
```
.除了换行和回车之外的任意字符
\d数字字符
\D非数字字符
\s空白字符
\S非空白字符
\w单词字符(等价于[A-Za-z0-9_])
\W非单词字符
\b单词边界
\B非单词边界
\xnn 由十六进制数nn指定的拉丁字符
\uxxxx 由十六进制数xxxx指定的Unicode字符
\cX 控制字符^X，例如\cJ等价于换行符\n(不常用)
```
## 量词类
?出现零次或一次
*出现零次或多次(任意次)
+出现一次或多次（至少一次）
{n}对应n次
{n,m}        至少出现n次但不超过m次
{n,}至少出现n次(+的升级版)

## 修饰符
g全局搜索。
i不区分大小写搜索。
m多行搜索。

## 分组
在一个小括号里，小括号允许我们重复多个字符。

## 反向引用
反向引用标识由正则表达式中的匹配组捕获的子字符串。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用,编号从1开始，最大为99
如：/(a)\1/ 匹配’aa’字符串

## 非捕获性分组
（？：）此括号内的分组，不被捕获

## 选择
如 /(a|n|c)/，选择a，n, c, 中任意一个

## 前瞻
(?=exp)正向前瞻匹配exp前面的位置
(?!exp)负向前瞻匹配后面不是exp的位置

## 贪婪匹配
规则如图：
![贪婪匹配](/img/reg1.jpg)
图片中列出的匹配重复字符是尽可能多的匹配，且允许后续的正则表达式继续匹配，我们称为贪婪匹配。

## 非贪婪匹配
我们同样可以不进行贪婪匹配，只需要在待匹配字符后面跟一个问号即可,
非贪婪匹配是只要匹配到量词后的条件，就停止匹配，与贪婪匹配不同的是贪婪匹配会尽可能多的匹配设置量词的匹配条件，非贪婪匹配，只要匹配到全部符合匹配条件的子串即可。
注意：/a+?b/匹配的并不是aaab中最后一个a和b，而是整个字符，原因：正则表达式的匹配模式总是会寻找第一个匹配子串，也就是说在执行时，首先发现aaa符合a+，发现aaa后直接匹配b，就返回了第一个匹配子串aaab
在es3中每次运算同一条正则时返回同一个正则对象，es5中每次运算同一条正则时都返回一个新的正则对象
注：这里的同一条正则指的是每次使用都重新声明，或者直接使用

## 锚元素
类似^（匹配字符串开始）, $（匹配字符串结尾）, \b（匹配单词边界）这样不匹配某个可见的字符，他们指定匹配发生的合法位置，我们称为锚元素
任意正则表达式都可以作为锚点条件，使用前面说的前瞻的法则
如:(?=某正则)

---

# 相关函数

## 用于模式匹配的string方法
1.Search(): 他的参数为一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到子串，返回-1.
如：

```
‘JavaScript’.search(/script/i); //返回4
```

2.replace(Reg,string/fun);Reg为一个正则表达式，第二个参数为一个字符串，或者一个函数fun()
注：’$n’为正则中通过()来捕获的捕获分组，0<n<99
![replace](/img/reg2.jpg)
函数fun（）中参数，注意其中p1,p2的个数取决于捕获分组的数目
![replace](/img/reg3.png)

3.match()方法是最常用的String正则表达式方法。它唯一的参数就是一个正则表达式，返回的是一个由匹配结果组成的数组，如果正则中设置了g，则该方法返回的数组包含字符串中所有匹配结果，例如：

```
‘1 plus 2 equals 3’.match(/\d+/g); //返回[‘1’,’2’,’3’]
```

如果不设置全局搜索g，它只检索第一个匹配，也会返回一个数组，在这种情况下，数组中第一元素是匹配字符，余下的元素则是正则表达式中用圆括号扩起来的子表达式，既捕获分组

4.split(),传入参数可以为一个字符串或者一个正则表达式，作用是以参数或者参数匹配的字符串为分隔符将字符串分割为数组
例如：

```
'123, 345, 456'.split(‘,’); //返回[‘123', ‘345', ‘456']
'1, 2, 3, 4, 5'.split(/\s*,\s*/);返回['1', '2', '3', '4', ‘5’]
```
## RegExp方法和属性
1.RegExp()构造函数，有两个参数，第二个是可选的，第一个参数为字符串，如’/d’,第二个参数则是添加修饰符g, i, m
每个RegExp对象有5个参数：source是一个只读字符串，包含正则表达式的文本，属性global, ignoreCase, multiline(bool)，说明是否有修饰符g, i , m ,都为只读属性，lastIndex是一个可读写的整数，如果匹配模式带有g，这个属性存储整个字符串，下一次开始检索的开始位置，这个属性会被exec()和test()方法用到。

2.exex() 其参数是一个字符串，此方法就是对一个字符串执行一个正则表达式，如果没有找到任何匹配，它会返回null，但如果找到一个匹配，它将会返回一个第一元素是匹配字符，余下的元素则是正则表达式中用圆括号扩起来的子表达式(既捕获分组)的数组,此数组属性index包含了发生匹配的字符位置，属性input引用的是正在检索的字符串,与match不同的地方在于不管是否全局搜索，它都会返回这样的数组,例如：
![exex](/img/reg4.png)
每次运行正则时，都会使用正则对象中的lastIndex，属性为开始遍历点,例如：
![exex](/img/reg5.png)

3.Test(),它的参数是字符串，如果参数里包含正则表达式的一个匹配结果，则返回true，它的行为和exec是同样的，都是从正则对象的lastIndex属性指定的位置开始检索

---

# 自己动手试试
说了这么多，咱们自己写个demo来练练吧

demo：要将字符串中’:某字符'替换为rule对象中所对应的值，若无对应值，不替换

答案：
![exex](/img/regan.png)